program _12f675_PwmFet;

{ 12F675 PWM controller

  Copyright (C) 2015 rasberryrabbit

  This source is free software; you can redistribute it and/or modify it under
  the terms of the GNU General Public License as published by the Free
  Software Foundation; either version 2 of the License, or MPL 1.1
  any later version.

  This code is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
  details.

  A copy of the GNU General Public License is available on the World Wide Web
  at <http://www.gnu.org/copyleft/gpl.html>. You can also obtain it by writing
  to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
  MA 02111-1307, USA.
}

const
   c160 = 931;   // 16.0 * 1024 / 17.6
   c138 = 803;   // 13.8 * 1024 / 17.6
   c123 = 716;   // 12.3 * 1024 / 17.6
   c118 = 686;   // 11.8 * 1024 / 17.6
   c108 = 628;   // 10.8 * 1024 / 17.6
   c051 = 297;   // 5.1 * 1024 / 17.6
   c046 = 270;   // 4.63 * 1024 / 17.6
   c045 = 264;   // 4.54 * 1024 / 17.6
   c043 = 254;   // 4.36 * 1024 / 17.6
   cLow = 17;    // 0.3 * 1024 / 17.6
   { 4MHz }
   PWM_MAX = 255;   // 1000000 / 4 / 255
   PWM_LOW = 0;
   TMR1L_LOAD=$38; // 1000000 / 1000
   TMR1H_LOAD=$fc;
   cShort_Recover = 10;
   cAdc_Limit = 19;

var
   LED1:sbit at GP2_bit;
   PWM_SIG:sbit at GP0_bit;
   VOut5:sbit at GP3_bit;     // pin 4
   VCharge:sbit at GP4_bit;   // pin 3
   PWM_SYNC:sbit at GP5_bit;   // pin 2
   PWM_TICK, ON_PWM, VOL_PWM:byte;
   TICK_1000:Byte;
   
   adc_vol, adc_old:word;
   
   LED1_Timer:byte;
   LED1_Toggle:Boolean;
   LED1_tm:byte;
   
   out_short:Boolean;
   out_timer:Byte;
   out_488:byte;
   short_Timer:Byte;
   short_count:Byte;
   short_check:Boolean;
   vTarget:word;
   LED_TMCount:byte;


procedure Interrupt(); iv 0x0004; ics ICS_AUTO;
begin
     if T0IF_bit=1 then begin
       { PWM MAX 96% }
       if PWM_SIG=1 then begin
         ON_PWM:=VOL_PWM;
         if ON_PWM=0 then
           TMR0:=ON_PWM
         else begin
           TMR0:=PWM_MAX-ON_PWM;
           PWM_SYNC:=0;
           PWM_SIG:=0;
         end;
       end else begin
         TMR0:=ON_PWM;
         PWM_SIG:=1;
         PWM_SYNC:=1;
       end;
       T0IF_bit:=0;
     end;
     if T1IF_bit=1 then begin
       Inc(TICK_1000);
       TMR1L:=TMR1L_LOAD;
       TMR1H:=TMR1H_LOAD;
       T1IF_bit:=0;
     end;
end;

function Delay1ms(var t:byte; limit:byte):Boolean;
var
  ts:byte;
begin
  if limit>0 then begin
    ts:=TICK_1000;
    if t<=ts then
      ts:=ts-t
      else
        ts:=255-t+1+ts;
    Result:=ts>=limit;
  end else
    Result:=True;
  if Result then
    t:=TICK_1000;
end;

begin
     CMCON:=7;
     ANSEL:=%00000010;

     TRISIO0_bit:=0;
     TRISIO1_bit:=1;
     TRISIO2_bit:=0;
     TRISIO5_bit:=0;  // PWM_SYNC
     LED1:=0;
     PWM_SIG:=1;
     PWM_SYNC:=0;
     LED1_tm:=250;
     LED1_Toggle:=True;
     ON_PWM:=0;
     VOL_PWM:=0;
     out_short:=False;
     short_count:=cShort_Recover*2;
     short_check:=False;
     TICK_1000:=0;
     LED_TMCount:=0;

     OPTION_REG:=%01010000;        // ~2KHz @ 4MHz, enable weak pull-up
     //WPU5_bit:=1;
     WPU4_bit:=1;

     TMR0IE_bit:=1;
     PEIE_bit:=1;
     TMR1CS_bit:=0;
     TMR1IE_bit:=1;
     TMR1L:=TMR1L_LOAD;
     TMR1H:=TMR1H_LOAD;
     TMR1ON_bit:=1;
     GIE_bit:=1;      // enable Interrupt
      
     LED1_Timer:=TICK_1000;
     short_Timer:=TICK_1000;

     Delay_10ms;
     
     while True do begin
         if VOut5=0 then begin
           vTarget:=c051;
         end else begin
           vTarget:=c138;
         end;
         // PWM
         if (not out_short) then begin
             adc_vol:=ADC_Read(1);
             if (VOL_PWM>PWM_LOW) and (adc_vol<cLow) and short_check then begin
               VOL_PWM:=0;
               out_short:=True;
               out_timer:=TICK_1000;
               out_488:=10;         // 2 seconds
             end else begin
               if adc_vol<vTarget then begin
                 while adc_vol<vTarget do begin
                   if VOL_PWM<PWM_MAX then
                     Inc(VOL_PWM)
                     else
                       break;
                   adc_vol:=ADC_Read(1);
                 end;
                 if adc_vol>cLow then begin
                   while adc_vol>vTarget+cAdc_Limit do begin
                     if VOL_PWM>PWM_LOW then
                       Dec(VOL_PWM)
                       else
                         break;
                     adc_vol:=ADC_Read(1);
                   end;
                   if (VCharge=0) and (adc_vol>=vTarget) then
                     VOL_PWM:=0;
                 end;
               end else if adc_vol>vTarget then begin
                 while adc_vol>vTarget do begin
                   if VOL_PWM>PWM_LOW then
                     Dec(VOL_PWM)
                     else
                       break;
                   adc_vol:=ADC_Read(1);
                 end;
                 if adc_vol>cLow then begin
                   while adc_vol<vTarget-cAdc_Limit do begin
                     if VOL_PWM<PWM_MAX then
                       Inc(VOL_PWM)
                       else
                         break;
                     adc_vol:=ADC_Read(1);
                   end;
                   if (VCharge=0) and (adc_vol>=vTarget) then
                     VOL_PWM:=0;
                 end;
               end;
               short_check:=Delay1ms(short_Timer,short_count);
               if short_check then
                 short_count:=0;
               LED1_tm:=240;
             end;
         end else
         if out_short then begin
             if Delay1ms(out_timer,100) then begin
               Dec(out_488);
               if out_488=0 then begin
                 out_short:=False;
                 short_Timer:=TICK_1000;
                 short_count:=cShort_Recover;
                 short_check:=False;
                 VOL_PWM:=0;
               end;
             end;
         end;

         if (VOL_PWM=PWM_MAX) or (VOL_PWM=0) then begin
           if (VCharge=0) and (VOL_PWM=0) then begin
             LED_TMCount:=1;
             LED1_tm:=240;
           end else
               LED1_tm:=128;
         end;

         if not LED1_Toggle then begin
           LED1_Toggle:=True;
           LED1_Timer:=TICK_1000;
         end;
         if LED1_Toggle and Delay1ms(LED1_Timer,LED1_tm) then begin
           if LED_TMCount>0 then
             Dec(LED_TMCount);
           if LED_TMCount=0 then begin
             LED1:=not LED1;
           end;
         end;

     end;
end.