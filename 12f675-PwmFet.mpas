program _12f675_PwmFet;

{ 12F675 PWM controller

  Copyright (C) 2015 rasberryrabbit

  This source is free software; you can redistribute it and/or modify it under
  the terms of the GNU General Public License as published by the Free
  Software Foundation; either version 2 of the License, or MPL 1.1
  any later version.

  This code is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
  details.

  A copy of the GNU General Public License is available on the World Wide Web
  at <http://www.gnu.org/copyleft/gpl.html>. You can also obtain it by writing
  to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
  MA 02111-1307, USA.
}

{.$define USE_OSCAL}

const
   c160 = 931;   // 16.0 * 1024 / 17.6
   c138 = 803;   // 13.8 * 1024 / 17.6
   c123 = 716;   // 12.3 * 1024 / 17.6
   c118 = 686;   // 11.8 * 1024 / 17.6
   c108 = 628;   // 10.8 * 1024 / 17.6
   c051 = 297;   // 5.1 * 1024 / 17.6
   c046 = 270;   // 4.63 * 1024 / 17.6
   c045 = 264;   // 4.54 * 1024 / 17.6
   c043 = 254;   // 4.36 * 1024 / 17.6
   c025 = 146;   // 2.5 * 1024 / 17.6
   cLow = 17;    // 0.3 * 1024 / 17.6
   { 4MHz }
   PWM_MAX = 255;   // 1000000 / 4 / 255
   PWM_LOW = 0;
   
   { higher capacitor, higher current }
   PWM_DELAY51 = 5;
   PWM_DELAY138 = 0;

   TMR1L_LOAD=$17; // 1000000 / 1000, 65535-1000
   TMR1H_LOAD=$fc;

var
   LED1:sbit at GP2_bit;
   PWM_SIG:sbit at GP0_bit;
   VOut5:sbit at GP3_bit;     // pin 4
   PWM_SYNC:sbit at GP5_bit;   // pin 2
   PWM_TICK, ON_PWM, VOL_PWM:byte;
   TICK_1000:Byte;
   adc_vol:word;
   LED1_tm:byte;
   vTarget:word;
   i:byte;
   Tick_512:Byte;
   Tick_512_1:Byte;
   MaxLoad_Reset:bit;

procedure Interrupt(); iv 0x0004; ics ICS_AUTO;
begin
     if T0IF_bit=1 then begin
       { PWM MAX 96% }
       if PWM_SIG=1 then begin
         ON_PWM:=VOL_PWM;
         if ON_PWM=0 then
           TMR0:=ON_PWM
         else begin
           TMR0:=PWM_MAX-ON_PWM;
           PWM_SYNC:=0;
           PWM_SIG:=0;
         end;
       end else begin
         TMR0:=ON_PWM;
         PWM_SIG:=1;
         PWM_SYNC:=1;
       end;
       T0IF_bit:=0;
     end;
     if T1IF_bit=1 then begin
       Inc(TICK_1000);
       TMR1L:=TMR1L_LOAD;
       TMR1H:=TMR1H_LOAD;
       if TICK_1000>LED1_Tm then begin
         LED1:=not LED1;
         TICK_1000:=0;
       end;
       Inc(Tick_512);   // reset PWM every 6 seconds at Maxium PWM. it recover voltage drop on PV.
       if Tick_512=255 then begin
         Inc(Tick_512_1);
         if Tick_512_1=12 then begin
           if MaxLoad_Reset then
             VOL_PWM:=0;
           Tick_512_1:=0;
         end;
       end;
       T1IF_bit:=0;
     end;
     if GPIF_bit=1 then begin
         if VOut5=0 then
           vTarget:=c051
           else
           vTarget:=c138;
         GPIF_bit:=0;
     end;
end;

procedure Read_ADC;
begin
   GO_NOT_DONE_bit:=1;
   while GO_NOT_DONE_bit=1 do ;
   Hi(adc_vol):=ADRESH;
   Lo(adc_vol):=ADRESL;
end;

begin
     {$ifdef USE_OSCAL}
     OSCCAL:=$34;
     {$endif}
     CMCON:=7;
     ANSEL:=%00000010;

     TRISIO0_bit:=0;
     TRISIO1_bit:=1;
     TRISIO2_bit:=0;
     TRISIO5_bit:=0;  // PWM_SYNC
     LED1:=0;
     PWM_SIG:=1;
     PWM_SYNC:=0;
     LED1_tm:=250;
     ON_PWM:=0;
     VOL_PWM:=0;
     TICK_1000:=0;
     MaxLoad_Reset:=0;

     OPTION_REG:=%01010000;        // ~2KHz @ 4MHz, enable weak pull-up
     TMR0IE_bit:=1;
     
     ADCON0:=%10000101;            // ADC config
     
     PEIE_bit:=1;
     
     T1CKPS0_bit:=1;               // timer prescaler 1:2
     TMR1CS_bit:=0;
     TMR1IE_bit:=1;
     TMR1L:=TMR1L_LOAD;
     TMR1H:=TMR1H_LOAD;

     adc_vol:=0;
     
     IOC3_bit:=1;
     GPIE_bit:=1;

     GIE_bit:=1;                   // enable Interrupt
     
     ADON_bit:=1;
     TMR1ON_bit:=1;
     
     GO_NOT_DONE_bit:=1;
      
     Delay_10ms;
     
     if VOut5=0 then begin
       vTarget:=c051;
     end else begin
       vTarget:=c138;
     end;

     
     while True do begin

         Read_ADC;
         if (adc_vol>vTarget) then begin
             repeat
               if VOL_PWM>PWM_LOW then
                 Dec(VOL_PWM)
                   else break;
               if VOut5=0 then begin
                 for i:=0 to PWM_DELAY51 do begin
                   Read_ADC;
                   if adc_vol>vTarget+29 then begin
                     VOL_PWM:=0;
                     Read_ADC;
                     break;
                   end
                 end;
               end else begin
                 for i:=0 to PWM_DELAY138 do begin
                   Read_ADC;
                   if adc_vol>vTarget+29 then begin
                     VOL_PWM:=0;
                     Read_ADC;
                     break;
                   end;
                 end;
               end;
             until adc_vol<=vTarget;
         end else if (adc_vol<vTarget) then begin
             repeat
               if VOL_PWM<PWM_MAX then begin
                 Inc(VOL_PWM);
                 MaxLoad_Reset:=0;
               end else begin
                     MaxLoad_Reset:=1;
                     break;
                   end;
               if VOut5=0 then begin
                 for i:=0 to PWM_DELAY51 do begin
                   Read_ADC;
                   if adc_vol>vTarget+29 then begin
                     VOL_PWM:=VOL_PWM shr 4;
                     Read_ADC;
                     break;
                   end;
                 end;
               end else begin
                 for i:=0 to PWM_DELAY138 do begin
                   Read_ADC;
                   if adc_vol>vTarget+29 then begin
                     VOL_PWM:=VOL_PWM shr 4;
                     Read_ADC;
                   end;
                 end;
               end;
             until adc_vol>=vTarget;
         end;

         if (Hi(adc_vol)=0) and (Lo(adc_vol)<=cLow) then
           LED1_tm:=64
           else if VOL_PWM=PWM_MAX then
             LED1_tm:=128
               else
                 LED1_tm:=240;
    end;
end.